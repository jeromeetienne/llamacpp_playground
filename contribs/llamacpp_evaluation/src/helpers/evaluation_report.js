// node imports
import Path from 'path'
import Fs from 'fs'

// local imports
import Utils from "../utils.js";



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/**
 * @typedef {Object} EvaluationReportOptions
 * @property {Boolean} verbose
 */

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

export default class EvaluationReport {

	/**
	 * @param {string} evaluationName
	 * @param {Partial<EvaluationReportOptions>} partialOptions
	 */
	static async display(evaluationName, partialOptions = {}) {

		// handle default options
		partialOptions = Object.assign({}, /** @type {EvaluationReportOptions} */({
			verbose: false,
		}), partialOptions)
		const options = /** @type {EvaluationReportOptions} */(partialOptions)

		///////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////
		//	get prediction names
		///////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////

		// TODO put that into Utils
		const predictionNames = await Utils.getPredictionNames(evaluationName)
		const datasetJson = await Utils.loadEvaluationDatasetJson(evaluationName)

		///////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////
		//      build report array
		///////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////

		for (const predictionName of predictionNames) {
			const reportJson = await Utils.buildReportJson(evaluationName, predictionName)
			const predictionMetadataJson = await Utils.loadPredictionMetadataJson(evaluationName, predictionName)

			// Compute statistics
			let validCount = 0
			for (const reportItem of reportJson) {
				if (reportItem.predictionValid) validCount += 1
			}
			const evaluationScore = validCount / reportJson.length

			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////
			//	
			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////
			
			console.log(`OUTPUT REPORT FOR ${predictionName}`)
			if (options.verbose) {
				console.log(`${JSON.stringify(reportJson, null, '\t')}`)
			}
			// debugger
			for(const optionName of Object.keys(predictionMetadataJson.explicitOptions)){
				console.log(`\t- Explicit ${optionName}: ${predictionMetadataJson.explicitOptions[optionName]}`)
			}

			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////
			//	display statistics
			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////

			console.log(`\tDataset count: ${reportJson.length} items (${validCount} valid/${reportJson.length-validCount} invalid)`)
			console.log(`\tEvaluation score: ${(evaluationScore * 100).toFixed(2)}%`)

			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////
			//	if verbose, display invalid items
			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////

			if( options.verbose === true ){
				const hasInvalidItems = reportJson.some(reportItem => reportItem.predictionValid === false)
				if (hasInvalidItems === false) {
					console.log('No invalid items')
				} else {
					for (const reportItem of reportJson) {
						const itemIndex = reportJson.indexOf(reportItem)
						if (reportItem.predictionValid) {
							continue
						}
						console.log(`items ${itemIndex} INVALID`)
						console.log(JSON.stringify(reportItem, null, '\t'))
					}
				}	
			}
		}
	}
}
